import java.util.Scanner;
import java.util.Stack;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in); // Scanner to read input from the user
        System.out.println("Enter the Expression");

        String s = sc.nextLine(); // Read the Infix expression from user

        String postfix = infixToPostfix(s); // Convert Infix to Postfix

        System.out.println("Output is " + postfix); // Print the Postfix result
    }

    // Function to convert Infix expression to Postfix
    public static String infixToPostfix(String s) {

        Stack<Character> stack = new Stack<>();          // Stack to hold operators and parentheses
        StringBuilder postfix = new StringBuilder();     // StringBuilder for the final output

        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);

            if (c == ' ' || c == ',') continue;          // Ignore spaces and commas

            else if (isOperand(c)) {                     // If the character is an operand (letter or digit)
                postfix.append(c);                       // Add it directly to the output
            }

            else if (c == '(') {                         // If the character is '('
                stack.push(c);                           // Push it to the stack
            }

            else if (c == ')') {                         // If the character is ')'
                // Pop from stack until '(' is found
                while (!stack.isEmpty() && stack.peek() != '(') {
                    postfix.append(stack.pop());
                }
                if (!stack.isEmpty()) stack.pop();      // Remove '(' from the stack
            }

            else if (isOperator(c)) {                    // If the character is an operator
                // Pop operators from the stack with higher or equal precedence
                while (!stack.isEmpty() && stack.peek() != '(' && hasHigherPrecedence(stack.peek(), c)) {
                    postfix.append(stack.pop());
                }
                stack.push(c);                           // Push the new operator onto the stack
            }
        }

        // Pop any remaining operators from the stack
        while (!stack.isEmpty()) {
            postfix.append(stack.pop());
        }

        return postfix.toString();                       // Return the final Postfix expression
    }

    // Function to check if operator on the stack has higher precedence than the new operator
    public static boolean hasHigherPrecedence(char c1, char c2) {
        int w1 = getWeight(c1); // Weight of operator on the stack
        int w2 = getWeight(c2); // Weight of the new operator

        if (w1 == w2) {        // If both operators have the same weight
            return !isRightAssociative(c1); // True if operator on stack is left-associative
        }

        return w1 > w2;         // True if stack operator has higher precedence
    }

    // Function to check if an operator is right-associative (only '$' here)
    public static boolean isRightAssociative(char c) {
        return c == '$';
    }

    // Function to check if a character is an operand (letter or digit)
    public static boolean isOperand(char c) {
        return (c >= '0' && c <= '9') ||
                (c >= 'a' && c <= 'z') ||
                (c >= 'A' && c <= 'Z');
    }

    // Function to check if a character is an operator
    public static boolean isOperator(char c) {
        return c == '+' || c == '-' || c == '*' || c == '/' || c == '$';
    }

    // Function to return weight/precedence of operators
    public static int getWeight(char c) {
        switch (c) {
            case '+':
            case '-':
                return 1;
            case '*':
            case '/':
                return 2;
            case '$':
                return 3; // Highest precedence for exponentiation
        }
        return 0;
    }
}
